COMMENT		: COMMENT_L|COMMENT_ML
COMMENT_L	: '//' ~[\n\r]*
COMMENT_ML	: '/*' .*? '*/'
STRING		: STRING_STD|STRING_ESC
STRING_SKIP	: '\\"' | '\\\\'
STRING_STD	: '"' (STRING_SKIP|.)*? '"'
STRING_ESC	: '@'('"' ~["]* '"')+
LITERAL		: '\'' ('\\\''|'\\\\'|.)*? '\''
DECLARATION_CODE : '%{' (STRING|COMMENT|.)*? '%}'

RULE_HEADER : %linestart ID
ID : [_a-zA-Z][_0-9a-zA-Z]*
DECLARATION_NAME : '%'ID

grammar 		=	declaration* '%%' (rule | Any)* grammar_ending
grammar_ending	=	('%%' Any)?

declaration		=	symbol_declaration | other_declaration | Any
symbol_declaration_header = ('%token' | '%left' | '%nonassoc' | '%right' | '%type' | '%start') ('<' ID '>')?
symbol_declaration = symbol_declaration_header symbol+
symbol = ID | LITERAL
other_declaration = DECLARATION_NAME Any

rule			=	RULE_HEADER ':' alternative ('|' alternative)* ';'
alternative		=    (alternative_element | block)*
alternative_element    =    ID | LITERAL | '%prec'
block			=	'{' (AnyAvoid(RULE_HEADER)|block)+ '}'

%%

%parsing {
	ignoreundefined
	start grammar
	skip COMMENT STRING DECLARATION_CODE
	recovery
}

%customblock {
	start("/// land start")
	end("/// land end")
	basetoken COMMENT
}

%nodes {
	ghost declaration
	leaf alternative_element symbol symbol_declaration_header
}

%markup {
	land symbol_declaration rule alternative
	priority(0) ':' ';' '|'
	notUnique alternative_element
	headerCore(RULE_HEADER) rule
	headerCore(alternative_element) alternative
	headerCore(symbol_declaration_header) symbol_declaration
}